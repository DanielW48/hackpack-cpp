{
    "MinQueue.h": {
        "body": [
            "template <typename T, class Compare = less<T>>",
            "struct min_queue : queue<T> {",
            "\tusing q = queue<T>;",
            "\tdeque<T> mq;",
            "\tCompare cmp;",
            "\tconst T& min() { return assert(!q::empty()), mq.front(); }",
            "\tvoid update() {",
            "\t\twhile (!mq.empty() && cmp(q::back(), mq.back()))",
            "\t\t\tmq.pop_back();",
            "\t\tmq.push_back(q::back());",
            "\t}",
            "\tvoid pop() {",
            "\t\tassert(!q::empty());",
            "\t\tif (!mq.empty() && !cmp(mq.front(), q::front()))",
            "\t\t\tmq.pop_front();",
            "\t\tq::pop();",
            "\t}",
            "\tvoid push(const T& val) { queue<T>::push(val), update(); }",
            "\tvoid push(T&& val) { queue<T>::push(val), update(); }",
            "\ttemplate <class... Args>",
            "\tvoid emplace(Args&&... args) {",
            "\t\tq::emplace(args...), update();",
            "\t}",
            "};"
        ],
        "description": "Queue that maintains its minimum element.",
        "prefix": [
            "hack_MinQueue"
        ]
    }
}