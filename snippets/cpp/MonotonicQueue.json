{
    "MonotonicQueue.h": {
        "body": [
            "template <typename T, class Compare = less<T>>",
            "struct monotonic_queue : queue<T> {",
            "\tusing q = queue<T>;",
            "\tdeque<T> mq;",
            "\tCompare cmp;",
            "\tconst T& min() { return assert(!q::empty()), mq.front(); }",
            "\tvoid update() {",
            "\t\twhile (!mq.empty() && cmp(q::back(), mq.back()))",
            "\t\t\tmq.pop_back();",
            "\t\tmq.push_back(q::back());",
            "\t}",
            "\tvoid pop() {",
            "\t\tassert(!q::empty());",
            "\t\tif (!mq.empty() && !cmp(mq.front(), q::front()))",
            "\t\t\tmq.pop_front();",
            "\t\tq::pop();",
            "\t}",
            "\tvoid push(const T& val) { queue<T>::push(val), update(); }",
            "\tvoid push(T&& val) { queue<T>::push(val), update(); }",
            "\ttemplate <class... Args>",
            "\tvoid emplace(Args&&... args) {",
            "\t\tq::emplace(args...), update();",
            "\t}",
            "};"
        ],
        "description": "Queue that maintains its minimum/maximum\nelement. Time: Amortized $O(1)$ for \\texttt{push()}, true\n$O(1)$ for \\texttt{pop()}/\\texttt{min()}. Usage: Works\nexactly like std::queue; monotonic_queue<T> gives a min\nqueue, and monotonic_queue<T, greater<T>> gives a max queue.",
        "prefix": [
            "hack_MonotonicQueue"
        ]
    }
}