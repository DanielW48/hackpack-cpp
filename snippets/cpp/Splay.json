{
    "Splay.h": {
        "body": [
            "struct node {",
            "\tnode *ch[2] = {0}, *p = 0;",
            "\tint cnt = 1, val;",
            "",
            "\tnode(int val, node* l = 0, node* r = 0)",
            "\t\t: ch{l, r}, val(val) {}",
            "};",
            "",
            "int cnt(node* x) { return x ? x->cnt : 0; }",
            "int dir(node* p, node* x) { return p && p->ch[0] != x; }",
            "void setLink(node* p, node* x, int d) {",
            "\tif (p) p->ch[d] = x;",
            "\tif (x) x->p = p;",
            "}",
            "",
            "node* update(node* x) {",
            "\tif (!x) return 0;",
            "\tx->cnt = 1 + cnt(x->ch[0]) + cnt(x->ch[1]);",
            "\tsetLink(x, x->ch[0], 0);",
            "\tsetLink(x, x->ch[1], 1);",
            "\treturn x;",
            "}",
            "",
            "void prop(node* x) {",
            "\tif (!x) return;",
            "\t// update(x); // needed if prop() can change subtree sizes",
            "}",
            "",
            "void rotate(node* x, int d) {",
            "\tif (!x || !x->ch[d]) return;",
            "\tnode *y = x->ch[d], *z = x->p;",
            "\tsetLink(x, y->ch[d ^ 1], d);",
            "\tsetLink(y, x, d ^ 1);",
            "\tsetLink(z, y, dir(z, x));",
            "\tupdate(x);",
            "\tupdate(y);",
            "}",
            "",
            "node* splay(node* x) {",
            "\twhile (x && x->p) {",
            "\t\tnode *y = x->p, *z = y->p;",
            "\t\t// prop(z), prop(y), prop(x); // needed for LCT",
            "\t\tint dy = dir(y, x), dz = dir(z, y);",
            "\t\tif (!z)",
            "\t\t\trotate(y, dy);",
            "\t\telse if (dy == dz)",
            "\t\t\trotate(z, dz), rotate(y, dy);",
            "\t\telse",
            "\t\t\trotate(y, dy), rotate(z, dz);",
            "\t}",
            "\treturn x;",
            "}",
            "",
            "// the returned node becomes the new root, update the root",
            "// pointer!",
            "node* nodeAt(node* x, int pos) {",
            "\tif (!x) return 0;",
            "\twhile (prop(x), cnt(x->ch[0]) != pos)",
            "\t\tif (pos < cnt(x->ch[0]))",
            "\t\t\tx = x->ch[0];",
            "\t\telse",
            "\t\t\tpos -= cnt(x->ch[0]) + 1, x = x->ch[1];",
            "\treturn splay(x);",
            "}",
            "",
            "node* merge(node* l, node* r) {",
            "\tif (!l || !r) return l ?: r;",
            "\tl = nodeAt(l, cnt(l) - 1);",
            "\tsetLink(l, r, 1);",
            "\treturn update(l);",
            "}",
            "",
            "// first is everything < pos, second is >= pos",
            "pair<node*, node*> split(node* t, int pos) {",
            "\tif (pos <= 0 || !t) return {0, t};",
            "\tif (pos > cnt(t)) return {t, 0};",
            "\tnode *l = nodeAt(t, pos - 1), *r = l->ch[1];",
            "\tif (r) l->ch[1] = r->p = 0;",
            "\treturn {update(l), update(r)};",
            "}",
            "",
            "// insert a new node between pos-1 and pos",
            "node* insert(node* t, int pos, int val) {",
            "\tauto [l, r] = split(t, pos);",
            "\treturn update(new node(val, l, r));",
            "}",
            "",
            "// apply lambda to all nodes in an inorder traversal",
            "template <class F>",
            "void each(node* x, F f) {",
            "\tif (x) prop(x), each(x->ch[0], f), f(x), each(x->ch[1], f);",
            "}"
        ],
        "description": "An implicit balanced BST. You only need to\nchange \\texttt{update()} and \\texttt{prop()}. \\\\\nIf used for link-cut tree, code everything up to\n\\texttt{splay()}. Time: amortized $O(\\log n)$ for all\noperations",
        "prefix": [
            "hack_Splay"
        ]
    }
}